type = 'l',
lwd = 3,
col = 'black')
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
# Top pane: Series and Forecast.
par(fig = c(0, 1, 0.4, 1.0), new = TRUE, mar = c(2.1, 4.1, 4.1, 2.1))
col_num <- 1
plot(seriesF[, col_num],
# main = 'Series, including Forecast',
main = 'Variables and Equilibrium Relation with Forecast',
# xlab = 'Time, t',
ylab = 'Variables',
ylim = c(yMinS, yMaxS),
type = 'l',
lwd = 3,
col = color_list[col_num])
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
for (col_num in 2:ncol(seriesF)) {
lines(seriesF[, col_num],
lwd = 3,
lty = col_num,
col = color_list[col_num])
}
legend(150, 20, legend = label_list,
col = color_list, lty = 1:3, cex = 1.0)
dev.off()
# Bottom pane: Equilibrium Relation
par(fig = c(0, 1, 0, 0.4), new = TRUE, mar = c(4.1, 4.1, 1.1, 2.1))
# Reset after.
# par(fig = c(0, 1, 0, 1), new = FALSE, mar = c(5.1, 4.1, 4.1, 2.1))
plot(equilF,
# main = 'Equilibrium Relation, including Forecast',
xlab = 'Time, t',
# ylab = 'Equilibrium Relation',
ylab = 'Equilibrium',
ylim = c(yMinEq, yMaxEq),
type = 'l',
lwd = 3,
col = 'black')
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
# Top pane: Series and Forecast.
par(fig = c(0, 1, 0.4, 1.0), new = TRUE, mar = c(2.1, 4.1, 4.1, 2.1))
col_num <- 1
plot(seriesF[, col_num],
# main = 'Series, including Forecast',
main = 'Variables and Equilibrium Relation with Forecast',
# xlab = 'Time, t',
ylab = 'Variables',
ylim = c(yMinS, yMaxS),
type = 'l',
lwd = 3,
col = color_list[col_num])
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
for (col_num in 2:ncol(seriesF)) {
lines(seriesF[, col_num],
lwd = 3,
lty = col_num,
col = color_list[col_num])
}
legend(150, 20, legend = label_list,
col = color_list, lty = 1:3, cex = 1.0)
out_file_path <- sprintf('R_dev/Figures/forecast_vars_eqbm.%s', fig_ext)
plot.new()
png(out_file_path)
# Bottom pane: Equilibrium Relation
par(fig = c(0, 1, 0, 0.4), new = TRUE, mar = c(4.1, 4.1, 1.1, 2.1))
# Reset after.
# par(fig = c(0, 1, 0, 1), new = FALSE, mar = c(5.1, 4.1, 4.1, 2.1))
plot(equilF,
# main = 'Equilibrium Relation, including Forecast',
xlab = 'Time, t',
# ylab = 'Equilibrium Relation',
ylab = 'Equilibrium',
ylim = c(yMinEq, yMaxEq),
type = 'l',
lwd = 3,
col = 'black')
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
# Top pane: Series and Forecast.
par(fig = c(0, 1, 0.4, 1.0), new = TRUE, mar = c(2.1, 4.1, 4.1, 2.1))
col_num <- 1
plot(seriesF[, col_num],
# main = 'Series, including Forecast',
main = 'Variables and Equilibrium Relation with Forecast',
# xlab = 'Time, t',
ylab = 'Variables',
ylim = c(yMinS, yMaxS),
type = 'l',
lwd = 3,
col = color_list[col_num])
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
for (col_num in 2:ncol(seriesF)) {
lines(seriesF[, col_num],
lwd = 3,
lty = col_num,
col = color_list[col_num])
}
legend(200, 20, legend = label_list,
col = color_list, lty = 1:3, cex = 1.0)
dev.off()
# Bottom pane: Equilibrium Relation
par(fig = c(0, 1, 0, 0.4), new = TRUE, mar = c(5.1, 4.1, 1.1, 2.1))
# Reset after.
# par(fig = c(0, 1, 0, 1), new = FALSE, mar = c(5.1, 4.1, 4.1, 2.1))
plot(equilF,
# main = 'Equilibrium Relation, including Forecast',
xlab = 'Time, t',
# ylab = 'Equilibrium Relation',
ylab = 'Equilibrium',
ylim = c(yMinEq, yMaxEq),
type = 'l',
lwd = 3,
col = 'black')
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
png(out_file_path)
# Bottom pane: Equilibrium Relation
par(fig = c(0, 1, 0, 0.4), new = TRUE, mar = c(5.1, 4.1, 1.1, 2.1))
# Reset after.
# par(fig = c(0, 1, 0, 1), new = FALSE, mar = c(5.1, 4.1, 4.1, 2.1))
plot(equilF,
# main = 'Equilibrium Relation, including Forecast',
xlab = 'Time, t',
# ylab = 'Equilibrium Relation',
ylab = 'Equilibrium',
ylim = c(yMinEq, yMaxEq),
type = 'l',
lwd = 3,
col = 'black')
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
# Top pane: Series and Forecast.
par(fig = c(0, 1, 0.4, 1.0), new = TRUE, mar = c(2.1, 4.1, 4.1, 2.1))
col_num <- 1
plot(seriesF[, col_num],
# main = 'Series, including Forecast',
main = 'Variables and Equilibrium Relation with Forecast',
# xlab = 'Time, t',
ylab = 'Variables',
ylim = c(yMinS, yMaxS),
type = 'l',
lwd = 3,
col = color_list[col_num])
abline(v = T, col = 'black', lwd = 3, lty = 'dashed')
for (col_num in 2:ncol(seriesF)) {
lines(seriesF[, col_num],
lwd = 3,
lty = col_num,
col = color_list[col_num])
}
legend(200, 20, legend = label_list,
col = color_list, lty = 1:3, cex = 1.0)
dev.off()
# Assign model.
modelRstrct <- m1r4
# Perform Normalization.
G <- solve(modelRstrct$coeffs$betaHat[1:r, 1:r])
betaHatR <- modelRstrct$coeffs$betaHat %*% G
# alphaHat is post multiplied by G^{-1} so that pi = a(G^{-1})Gb' = ab'
alphaHatR <- modelRstrct$coeffs$alphaHat %*% t(solve(G))
# Print output.
print('betaHatR = ')
print(betaHatR)
print('alphaHatR = ')
print(alphaHatR)
print("betaHatR' = ")
print(t(betaHatR))
# Print output.
print("betaHatR' = ")
print(t(betaHatR))
print("alphaHatR' = ")
print(t(alphaHatR))
?print
print(t(alphaHatR), digits = 2)
print(t(alphaHatR), digits = 4)
print(t(alphaHatR), zero.print = '.')
print(t(alphaHatR), print.gap = 5)
print("betaHatR' = ")
print(t(betaHatR), print.gap = 5)
print("alphaHatR' = ")
print(t(alphaHatR), print.gap = 5)
opt <- FCVARoptions()
# save(opt, list = c('opt'), file = 'tests/testthat/soln_estn/opt.RData')
# FCVARoptionUpdates(opt, p, r)
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
newOpt <- FCVARoptionUpdates(opt, p = 3, r = 1)
# save(newOpt, list = c('newOpt'), file = 'tests/testthat/soln_estn/newOpt.RData')
opt <- FCVARoptions()
UB_LB_bounds <- GetBounds(opt)
opt <- FCVARoptions()
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
UB_LB_bounds <- GetBounds(opt)
# save(UB_LB_bounds, list = c('UB_LB_bounds'), file = 'tests/testthat/soln_estn/UB_LB_bounds_mod.RData')
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
results <- FCVARestn(x, k = 2, r = 1, opt)
opt1 <- opt
opt1$R_psi <- matrix(c(1, 0), nrow = 1, ncol = 2)
opt1$r_psi <- 1
m1r1 <- FCVARestn(x1, k = 2, r = 1, opt1)
par(fig = c(0, 1, 0, 1), new = FALSE, mar = c(5.1, 4.1, 4.1, 2.1))
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
results <- FCVARestn(x, k = 2, r = 1, opt)
devtools::load_all()
devtools::document()
getwd()
?FCVARbootRank
# Restrict equality of fractional parameters.
opt <- FCVARoptions()
opt$dbStep1D     <- 0.1 # Coarser grid for plotting example.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
opt$restrictDB   <- 1 # impose restriction d=b ? 1 <- yes, 0 <- no.
opt$progress     <- 2 # Show progress report on each value of b.
newOpt <- FCVARoptionUpdates(opt, p = 3, r = 1) # Need to update restriction matrices.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
likeGrid_params <- FCVARlikeGrid(x, k = 2, r = 1, newOpt)
plot.FCVARlikeGrid(likeGrid_params, k = 2, r = 1, newOpt, main = 'default')
# Linear restriction on fractional parameters.
opt <- FCVARoptions()
opt$dbStep1D     <- 0.1 # Coarser grid for plotting example.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
opt$restrictDB   <- 0 # impose restriction d=b ? 1 <- yes, 0 <- no.
# Impose linear restriction on d and b:
opt$R_psi        <- matrix(c(2, -1), nrow = 1, ncol = 2)
opt$r_psi        <- 0.5
opt$progress     <- 2 # Show progress report on each value of b.
newOpt <- FCVARoptionUpdates(opt, p = 3, r = 1) # Need to update restriction matrices.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
likeGrid_params <- FCVARlikeGrid(x, k = 2, r = 1, newOpt)
devtools::load_all()
devtools::document()
?FCVARlikeGrid
devtools::check()
usethis::use_build_ignore(c("stata", "R_dev", "MATLAB", "article"))
?nextn
?end
devtools::load_all()
devtools::document()
devtools::test()
devtools::check()
MVWN
set.seed(27)
version
devtools::check()
?print.MVWNtest
devtools::check()
devtools::check()
?FCVARlike
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
results <- FCVARestn(x, k = 2, r = 1, opt)
FCVARlike(c(results$coeffs$db, results$coeffs$muHat), x, k = 2, r = 1, opt)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
read.00Index(file = 'demo/00Index')
library(tools)
read.00Index(file = 'demo/00Index')
read.00Index(file = 'demo/00Index')
read.00Index(file = 'demo/00Index')
read.00Index(file = 'demo/00Index')
read.00Index(file = 'INDEX')
getwd()
read.00Index(file = 'demo/00Index')
devtools::check()
opt <- FCVARoptions()
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
mean(x)
summary(x)
colMeans(x)
mu = colMeans(x)
mu
matrix(1, nrow = 5, ncol = 1) %*% mu
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::load_all()
devtools::test()
set.seed(42)
WN <- matrix(rnorm(200), nrow = 100, ncol = 2)
MVWNtest_stats <- MVWNtest(x = WN, maxlag = 10, printResults = 1)
MVWNtest_stats
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
results <- FCVARestn(x, k = 2, r = 1, opt)
MVWNtest_stats <- MVWNtest(x = results$Residuals, maxlag = 12, printResults = 1)
MVWNtest_stats
print.MVWNtest(stats = MVWNtest_stats, maxlag = 12)
devtools::load_all()
devtools::test()
?MVWN
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::test()
devtools::check()
devtools::load_all()
devtools::document()
devtools::check()
devtools::check()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::test()
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
FCVARlagSelectStats <- FCVARlagSelect(x, kmax = 3, r = 3, order = 12, opt)
capture.output(FCVARlagSelectStats <- FCVARlagSelect(x, kmax = 3, r = 3, order = 12, opt), file = 'tests/testthat/soln_spec/FCVARlagSelectStats.txt')
save(FCVARlagSelectStats, list = c('FCVARlagSelectStats'), file = 'tests/testthat/soln_spec/FCVARlagSelectStats.RData')
devtools::test()
devtools::check()
devtools::check()
devtools::check()
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
rankTestStats <- FCVARrankTests(x, k = 2, opt)
capture.output(rankTestStats <- FCVARrankTests(x, k = 2, opt), file = 'tests/testthat/soln_spec/rankTestStats.txt')
save(rankTestStats, list = c('rankTestStats'), file = 'tests/testthat/soln_spec/rankTestStats.RData')
devtools::check()
?results
FCVAR_model
devtools::document()
devtools::load_all()
devtools::test()
devtools::document()
devtools::load_all()
devtools::test()
devtools::document()
devtools::load_all()
devtools::test()
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
results <- FCVARestn(x, k = 2, r = 1, opt)
attributes(results)
results$class
results$names
names(results)
class(results)
attributes(results)
save(results, list = c('results'), file = 'tests/testthat/soln_estn/results_m1.RData')
opt1 <- opt
opt1$R_psi <- matrix(c(1, 0), nrow = 1, ncol = 2)
opt1$r_psi <- 1
m1r1 <- FCVARestn(x, k = 2, r = 1, opt1)
opt1 <- opt
opt1$R_Beta <- matrix(c(1, 0, 0), nrow = 1, ncol = 3)
m1r2 <- FCVARestn(x, k = 2, r = 1, opt1)
opt1 <- opt
opt1$R_Alpha <- matrix(c(0, 1, 0), nrow = 1, ncol = 3)
m1r4 <- FCVARestn(x, k = 2, r = 1, opt1)
save(m1r1, m1r2, m1r4,
list = c('m1r1', 'm1r2', 'm1r4'),
file = 'tests/testthat/soln_estn/results_m1r124.RData')
devtools::document()
devtools::load_all()
devtools::test()
opt <- FCVARoptions()
opt$gridSearch   <- 0 # Disable grid search in optimization.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # Impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
opt$plotRoots <- 0
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
set.seed(42)
FCVARbootRank_stats <- FCVARbootRank(x[1:50, ], k = 2, opt, r1 = 0, r2 = 1, B = 5)
FCVARbootRank_stats
save(FCVARbootRank_stats, list = c('FCVARbootRank_stats'), file = 'tests/testthat/soln_spec/FCVARbootRank_stats.RData')
devtools::load_all()
devtools::test()
devtools::check()
# Example of function with dots as arguments.
test_dots <- function(x, ...) {
dots <- list(...)
print(names(dots))
if (main %in% names(dots)) {
print('main = ')
print(main)
} else {
print('main not specified.')
}
return(100*x^2)
}
test_dots(x = 4)
# Example of function with dots as arguments.
test_dots <- function(x, ...) {
dots <- list(...)
print(names(dots))
if ('main' %in% names(dots)) {
print('main = ')
print(main)
} else {
print('main not specified.')
}
return(100*x^2)
}
test_dots(x = 4)
test_dots(x = 5, main = 'bananas')
# Example of function with dots as arguments.
test_dots <- function(x, ...) {
dots <- list(...)
print(names(dots))
if ('main' %in% names(dots)) {
main <- dots$main
print('main = ')
print(main)
} else {
print('main not specified.')
}
return(100*x^2)
}
test_dots(x = 4)
test_dots(x = 5, main = 'bananas')
test_dots(x = 6, y = 7, fruit = 'oranges')
devtools::document()
devtools::load_all()
devtools::test()
# Restrict equality of fractional parameters.
opt <- FCVARoptions()
opt$dbStep1D     <- 0.1 # Coarser grid for plotting example.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
opt$restrictDB   <- 1 # impose restriction d=b ? 1 <- yes, 0 <- no.
opt$progress     <- 2 # Show progress report on each value of b.
newOpt <- FCVARoptionUpdates(opt, p = 3, r = 1) # Need to update restriction matrices.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
likeGrid_params <- FCVARlikeGrid(x, k = 2, r = 1, newOpt)
plot(x = likeGrid_params)
plot.FCVARlikeGrid(likeGrid_params, k = 2, r = 1, newOpt, main = 'default')
plot(x = likeGrid_params, main = 'This is a test')
opt <- FCVARoptions()
opt$dbStep1D     <- 0.1 # Coarser grid for plotting example.
opt$dbMin        <- c(0.01, 0.01) # Set lower bound for d,b.
opt$dbMax        <- c(2.00, 2.00) # Set upper bound for d,b.
opt$constrained  <- 0 # impose restriction dbMax >= d >= b >= dbMin ? 1 <- yes, 0 <- no.
opt$restrictDB   <- 0 # impose restriction d=b ? 1 <- yes, 0 <- no.
# Impose linear restriction on d and b:
opt$R_psi        <- matrix(c(2, -1), nrow = 1, ncol = 2)
opt$r_psi        <- 0.5
opt$progress     <- 2 # Show progress report on each value of b.
newOpt <- FCVARoptionUpdates(opt, p = 3, r = 1) # Need to update restriction matrices.
x <- votingJNP2014[, c("lib", "ir_can", "un_can")]
likeGrid_params <- FCVARlikeGrid(x, k = 2, r = 1, newOpt)
plot.FCVARlikeGrid(likeGrid_params, k = 2, r = 1, newOpt, main = 'default')
plot(x = likeGrid_params)
devtools::check()
fig_ext
devtools::check()
devtools::check()
devtools::check()
con
rm(list = ls(all = TRUE))
devtools::check()
devtools:::test(fresh=TRUE)
